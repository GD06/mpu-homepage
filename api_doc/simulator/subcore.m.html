<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>simulator.subcore API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#simulator.subcore.Subcore">Subcore</a></span>
        
          
  <ul>
    <li class="mono"><a href="#simulator.subcore.Subcore.__init__">__init__</a></li>
    <li class="mono"><a href="#simulator.subcore.Subcore.check_reg_usage">check_reg_usage</a></li>
    <li class="mono"><a href="#simulator.subcore.Subcore.check_warp_usage">check_warp_usage</a></li>
    <li class="mono"><a href="#simulator.subcore.Subcore.get_param_value">get_param_value</a></li>
    <li class="mono"><a href="#simulator.subcore.Subcore.get_special_reg_value">get_special_reg_value</a></li>
    <li class="mono"><a href="#simulator.subcore.Subcore.get_subcore_reg_addr">get_subcore_reg_addr</a></li>
    <li class="mono"><a href="#simulator.subcore.Subcore.reset_status">reset_status</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">simulator.subcore</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore" class="source">
    <pre><code>import simpy 
from copy import deepcopy 

from simulator.subcore_table import WarpInfoTable, WarpPipelineTable, StackTable 
from simulator.subcore_table import WarpPipelineTableEntry, DepTable, \
    RegTrackTable
from simulator.instr_cache import InstrLoadReq  
from simulator.register_file import RegisterFile 
from simulator.operand_collector import OperandCollector
from simulator.alu import ArithmeticLogicUnit
from simulator.sfu import SpecialFunctionUnit
from simulator.load_store_unit import LoadStoreUnit
from simulator.synchronization_unit import SynchronizationUnit
from simulator.control_flow_unit import ControlFlowUnit
from simulator.instr_instance import InstrEntry
from simulator.register_file_utility import RegFileOperandIOInterface, \
    OperandWriteReq
from simulator.instr_offload_engine import InstrOffloadEngine
from simulator.reg_move_engine import RegMoveEngine, RegMoveReq


class Subcore:

    def __init__(self, subcore_id, env, config, log, core):
        self.subcore_id = subcore_id 
        self.env = env 
        self.config = config 
        self.log = log
        self.core = core

        self.clock_unit = deepcopy(core.clock_unit) 
        self._loc_str = "Processor ID: {proc_id}, Core ID: {core_id}, " \
            "Subcore ID: {subcore_id}".format(
                proc_id=self.core.processor.proc_id,
                core_id=self.core.core_id,
                subcore_id=self.subcore_id, 
            )

        self.start_exec_cmd = simpy.Store(env, capacity=1)
        self.finish_exec_resp = simpy.Store(env, capacity=1) 

        self.num_active_warps = 0
        self.warp_info_table = WarpInfoTable(config=self.config, log=self.log) 
        self.warp_pipeline_table = \
            WarpPipelineTable(config=self.config, log=self.log)
        self.stack_table = StackTable(config=self.config, log=self.log)
        self.dep_table = DepTable(config=self.config, log=self.log)

        self.reg_file = RegisterFile(
            env=env, 
            log=log, 
            config=self.config,
            clock_unit=self.clock_unit,  
            reg_file_type="far-bank"
        )

        self.reg_track_table = RegTrackTable(
            config=self.config,
            log=self.log,
            reg_file=self.reg_file
        )

        self.rf_io_interface = RegFileOperandIOInterface(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            reg_file=self.reg_file,
            interface_type="far-bank",
        )

        self.reg_move_engine = RegMoveEngine(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            bus_arbiter=self.core.subcore_pg_bus_arbiter,
            engine_type="fb_reg_move"
        )

        self.instr_offload_engine = InstrOffloadEngine(
            env=self.env,
            config=self.config,
            log=self.log,
            reg_move_engine=self.reg_move_engine,
            subcore=self
        )

        # TODO make this port assignment more accurate
        # currently round-robin
        self.local_regfile_write_port_id_commit = 0
        self.base_regfile_write_port_id_commit = \
            self.config["base_regfile_write_port_id_fb_commit"]

        self.decode_buffer = []
        self.num_free_decode_buffer_slots = []
        for i in range(self.config["max_num_warp_per_subcore"]):
            self.decode_buffer.append(simpy.Store(env))
            self.num_free_decode_buffer_slots.append(
                self.config["decode_buffer_size"])

        self.execute_buffer = simpy.Store(
            env, capacity=(self.config["subcore_execute_buffer_size"])
        )

        self.writeback_buffer = simpy.Store(
            env, capacity=self.config["subcore_writeback_buffer_size"]
        )

        self.sync_buffer = simpy.Store(
            env, capacity=self.config["max_num_warp_per_subcore"]
        )

        self.bus_receive_buffer = simpy.Store(
            env, capacity=self.config["subcore_bus_receive_buffer_size"]
        )

        self.reg_base_ptr = 0

        # Execution Stage
        # arithemtic logic unit
        self.fb_alu = ArithmeticLogicUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            alu_type="far-bank"
        )
        self.opc_fb_alu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.fb_alu,
            opc_type="fb_alu"
        )
        
        # special function unit
        self.sfu = SpecialFunctionUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            subcore=self
        )
        self.opc_sfu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.sfu,
            opc_type="sfu"
        )

        # load-store unit
        self.lsu = LoadStoreUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            subcore=self
        )
        self.opc_lsu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.lsu,
            opc_type="lsu"
        )

        # control-flow unit
        self.cfu = ControlFlowUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            subcore=self
        )
        self.opc_cfu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.cfu,
            opc_type="cfu"
        )

        # synchronization unit
        self.syncu = SynchronizationUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            subcore=self
        )
        self.opc_syncu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.syncu,
            opc_type="syncu"
        )

        # Spawn a process for the fetch and decode subcore stages
        self.env.process(self._fetch_and_decode())

        # Spawn processes for the issue subcore stage
        for i in range(self.config["max_num_warp_per_subcore"]):
            self.env.process(self._issue(entry_id=i))

        # Spawn a process for the execute subcore stage 
        self.env.process(self._execute())

        # Spawn a process for the commit subcore stage 
        self.env.process(self._commit())

        # Spawn a process to receive data from the bus
        self.env.process(self._receive_bus_data())
        return 

    def reset_status(self):
        """Reset hardware status of subcores.This function is usually used 
        to reset subcore status between different calls of executing thread 
        blocks. 
        """
        self.num_active_warps = 0
        self.reg_base_ptr = 0

        # Reset the tables in the subcore  
        self.warp_info_table.reset()
        self.warp_pipeline_table.reset() 
        self.stack_table.reset() 
        self.dep_table.reset()
        self.reg_track_table.reset()

        return 

    def check_warp_usage(self, warp_usage):
        """Return whether the available slots in the warp table is sufficient 
        to accomodate a new thread block 
        """
        new_active_warps = self.num_active_warps + warp_usage 
        if new_active_warps > self.config["max_num_warp_per_subcore"]:
            return False 
        return True 

    def check_reg_usage(self, reg_usage_in_bytes):
        """Returen whether the available amount of register file is sufficient
        to accomodate a new thread block 
        """
        new_base_ptr = self.reg_base_ptr + reg_usage_in_bytes 
        if new_base_ptr > self.config["subcore_reg_file_size"]:
            return False 
        return True 

    def _load_from_icache(self, entry_id, pc):
        """This function loads the instruction from the instruction cache and 
        fill in the corresponding entry of the fetch table. 

        Args:
            entry_id: the position of the entry in the fetch table
            pc: the program counter of the instruction 
        """
        req = InstrLoadReq(
            subcore_id=self.subcore_id, entry_id=entry_id, pc=pc
        )
        yield self.core.icache.load_req_queque.put(req)
        self.log.debug(
            "{loc} at {time_stamp} cycle: Issue load for the "
            "instr with PC={pc} from the entry {entry_id}".format(
                loc=self._loc_str, time_stamp=self.env.now, pc=pc, 
                entry_id=entry_id
            )
        )

        resp = yield self.core.icache.load_resp_queue.get(
            lambda x: ((x.subcore_id == self.subcore_id) 
                       and (x.entry_id == entry_id) and (x.pc == pc)) 
        )
        self.log.debug(
            "{loc} at {time_stamp} cycle: Get the instruction "
            "with PC={pc} for the entry {entry_id}".format(
                loc=self._loc_str, time_stamp=self.env.now,
                pc=pc, entry_id=entry_id,
            )
        )

        self.warp_pipeline_table.entry[entry_id].instr = resp.instr 
        self.warp_pipeline_table.entry[entry_id].valid = True 

        return 

    def _need_fetch_stall(self, instr):
        """Check the fetch stage needs to be stalled waiting for the execution
        of the current instruction. We will stall the fetch stage on any 
        control flow instructions or synchronization instructions. 

        Args:
            instr: the instruction passed to be checked. 

        Returns:
            A boolean value, True or False, to indicate whether the fetch stage
                needs to be stalled. 
        """
        # Check whether it is a control flow instruction 
        if "dst_pc" in instr.metadata:
            return True 
        
        # Check whether it is a barrier instruction 
        if "bar_id" in instr.metadata: 
            return True 

        return False 

    def _fetch_and_decode(self):
        """This function executes the fetch and decode stages of the subcore 
        """
        while True:
            start_exec = yield self.start_exec_cmd.get() 
            assert start_exec == "start", "Unrecognized " \
                "commands: {}".format(start_exec) 

            curr_ptr = 0
            while True:
                # Step 1: check the exit condition
                all_finish = self.warp_pipeline_table\
                    .check_all_finished(self.num_active_warps)
                if all_finish is True:
                    break 

                curr_entry = deepcopy(self.warp_pipeline_table.entry[curr_ptr])

                # Step 2: skip the current warp if it is finished 
                if curr_entry.warp_finished:
                    curr_ptr = (curr_ptr + 1) % self.num_active_warps 
                    yield self.env.timeout(1 * self.clock_unit)
                    continue 

                # Step 3: check whether the current instruction is valid
                if not curr_entry.valid: 
                    if not curr_entry.issued_to_icache: 
                        self.warp_pipeline_table.entry[curr_ptr]\
                            .issued_to_icache = True
                        self.env.process(
                            self._load_from_icache(curr_ptr, curr_entry.pc)
                        )
                        curr_ptr = (curr_ptr + 1) % self.num_active_warps 

                    yield self.env.timeout(1 * self.clock_unit)
                    continue 

                # self.log.debug("{loc}: Entry {entry_id} got a valid " \
                #        "instruction with pc={pc}".format(
                #            loc=self._loc_str, 
                #            entry_id=curr_ptr, 
                #            pc=curr_entry.pc
                #        )
                #    )

                # Step 4: push into the next stage if resources are available 
                if not curr_entry.issued_to_decode:
                    if self.num_free_decode_buffer_slots[curr_ptr] > 0:
                        self.num_free_decode_buffer_slots[curr_ptr] = (
                            self.num_free_decode_buffer_slots[curr_ptr] - 1
                        )
                        pc = deepcopy(curr_entry.pc)
                        simt_mask = deepcopy(
                            self.stack_table.entry[curr_ptr].get_simt_mask() 
                        )
                        yield self.decode_buffer[curr_ptr].put(
                            (pc, simt_mask, curr_entry.instr)
                        ) 
                        self.warp_pipeline_table.entry[
                            curr_ptr].issued_to_decode = True 
                    else:
                        if curr_entry.skip_resource_contention: 
                            self.warp_pipeline_table.entry[
                                curr_ptr].skip_resource_contention = False 
                            curr_ptr = (curr_ptr + 1) % self.num_active_warps 
                        yield self.env.timeout(1 * self.clock_unit) 

                    continue 

                # Step 5: stall the fetch stage if needed 
                if self._need_fetch_stall(curr_entry.instr):
                    if not curr_entry.executed:
                        curr_ptr = (curr_ptr + 1) % self.num_active_warps 

                        yield self.env.timeout(1 * self.clock_unit) 
                        continue 

                # Step 6: check the SIMT stack to get the correct next PC
                next_pc = curr_entry.next_pc 
                while self.stack_table.entry[curr_ptr].check_converge(next_pc):
                    self.stack_table.entry[curr_ptr].pop() 
                    top_entry = self.stack_table.entry[curr_ptr].top()
                    next_pc = top_entry[1] 
                    yield self.env.timeout(1 * self.clock_unit)

                if next_pc >= self.warp_info_table.entry[curr_ptr].prog_length:
                    self.warp_pipeline_table\
                        .entry[curr_ptr].warp_finished = True 

                    yield self.env.timeout(1 * self.clock_unit)
                    continue 

                # Step 7: generate a new entry for the next PC
                new_warp_pipeline_table_entry = \
                    WarpPipelineTableEntry(pc=next_pc)
                self.warp_pipeline_table.entry[curr_ptr] = \
                    deepcopy(new_warp_pipeline_table_entry) 

                yield self.env.timeout(1 * self.clock_unit) 

        return

    def _issue(self, entry_id):
        """This function executes the issue stage of subcore including 
        checking operand dependencies and send instructions to the next 
        stage 
        """
        while True:
            instr_tuple = yield self.decode_buffer[entry_id].get()
            self.num_free_decode_buffer_slots[entry_id] += 1
            current_pc = instr_tuple[0]
            simt_mask = instr_tuple[1]
            instr = instr_tuple[2]

            self.log.debug(
                "{loc} Entry {entry_id} start checking the "
                "dependency of {instr} at {time_stamp} cycle".format(
                    loc=self._loc_str, entry_id=entry_id,
                    instr=instr.instr_str, time_stamp=self.env.now
                )
            )

            src_ops = []
            dst_ops = []

            if "pred_reg" in instr.metadata:
                src_ops.append(instr.metadata["pred_reg"].op_str)

            for each_op in instr.src_operands:
                if each_op.isreg():
                    src_ops.append(each_op.op_str)
            # self.log.debug("source operands: {}".format(src_ops))

            for each_op in instr.dst_operands:
                if each_op.isreg():
                    dst_ops.append(each_op.op_str) 
            # self.log.debug("destination operands: {}".format(dst_ops))

            # Check the dependency table until all dependencies are cleared 
            while True:
                yield self.env.timeout(1 * self.clock_unit)

                break_cond = True 
                
                for each_op in src_ops:
                    if not self.dep_table.entry[entry_id].check_read(each_op):
                        break_cond = False 
                        break 

                for each_op in dst_ops:
                    if not self.dep_table.entry[entry_id].check_write(each_op):
                        break_cond = False 
                        break 

                if break_cond:
                    break 

            self.log.debug(
                "{loc} Entry {entry_id} finished checking the "
                "dependency of {instr} at {time_stamp} cycle".format(
                    loc=self._loc_str, entry_id=entry_id,
                    instr=instr.instr_str, time_stamp=self.env.now
                )
            )

            # Update the dependency table to pend other instructions 
            for each_op in src_ops:
                self.dep_table.entry[entry_id].increase_read(each_op) 

            for each_op in dst_ops:
                self.dep_table.entry[entry_id].increase_write(each_op)

            # (TODO) model a more accurate timing here for recording register 
            # dependencies
            yield self.env.timeout(1 * self.clock_unit) 

            yield self.execute_buffer.put(
                (current_pc, simt_mask, entry_id, instr)
            )
        return 

    def get_subcore_reg_addr(self, reg_prefix, reg_index, entry_id):
        """This function calculates the absolute addrss of a register in the 
        register file of subcore. It also returns the size of registers with 
        the same name across threads in the whole warp.  
        
        Args:
            reg_prefix: the prefix of register name 
            reg_index: the index of the register 
            entry_id: the warp ID of this register 

        Returns:
            (reg_addr, reg_size): the stating address of this register in the 
                register file and the size of the whole register 
        """
        reg_base_addr = self.warp_info_table\
            .entry[entry_id].subcore_reg_base_addr 
        prefix_reg_base_addr = (
            reg_base_addr 
            + self.warp_info_table.entry[entry_id].prog_reg_offset[reg_prefix]
        )
        reg_size = self.warp_info_table\
            .entry[entry_id].prog_reg_size[reg_prefix]
        reg_addr = prefix_reg_base_addr + reg_index * reg_size

        self.log.debug(
            "{loc} Entry {entry_id} {reg_prefix}{reg_index} " 
            "starting from {reg_addr} with size {reg_size}".format(
                loc=self._loc_str, entry_id=entry_id, 
                reg_prefix=reg_prefix, reg_index=reg_index,
                reg_addr=reg_addr, reg_size=reg_size 
            )
        )
        return (reg_addr, reg_size)

    def get_param_value(self, param_name, entry_id):
        """This function gets the value of parameters including kernel function
        arguments and shared memory parameter. 

        Args:
            param_name: the parameter name
            entry_id: the entry ID the current warp. This ID is used to locate 
                shared memory base address and offset for the dynamically 
                allocated shared memory space 

        Returns:
            param_value: the value of parameter in its corresponding type 
        """
        prog_smem_offset = \
            self.warp_info_table.entry[entry_id].prog_smem_offset
        if param_name in self.core.param_dict:
            return self.core.param_dict[param_name]
        elif param_name in prog_smem_offset:
            base_addr = self.warp_info_table.entry[entry_id].smem_base_addr
            offset = (
                self.warp_info_table
                .entry[entry_id].prog_smem_offset[param_name]
            ) 
            return base_addr + offset 
        else: 
            raise NotImplementedError(
                "Unknown parameter:{}".format(param_name)
            )
        return 

    def get_special_reg_value(self, reg_name, entry_id):
        """This function is used to get the value of special registers storing 
        SIMT thread information, such as block ID and thread ID. 

        Args:
            reg_name: the name of special register 
            entry_id: the entry ID of the current warp so that block ID and 
                thread ID can be accurately located. 

        Returns:
            reg_value: an integer if the requested registr has the same value 
                for all threads in the same warp, or a list of values for 
                different values of threads in the same warp. 
        """
        index_mapper = {"z": 0, "y": 1, "x": 2}
        reg_prefix = reg_name.split(".")[0]
        reg_index = index_mapper[reg_name.split(".")[1]]

        if reg_prefix == "%ntid":
            return self.core.block_dim[reg_index]
        elif reg_prefix == "%ctaid":
            return self.warp_info_table.entry[entry_id].block_id[reg_index] 
        elif reg_prefix == "%tid":
            start_id = self.warp_info_table.entry[entry_id].thread_id[reg_index]
            if reg_index != 2:
                return start_id 
            else: 
                value_list = list(range(
                    start_id, start_id + self.config["num_threads_per_warp"]))
                return value_list 
        elif reg_prefix == "%nctaid":
            return self.core.grid_dim[reg_index] 
        else:
            raise NotImplementedError(
                "Unknown special register: {}".format(reg_name)
            )
        return 

    def _receive_bus_data(self):
        """This function receives data from subcore-pg buses
        """
        while True:
            packet = yield self.bus_receive_buffer.get()
            if isinstance(packet, RegMoveReq):
                self.reg_move_engine\
                    .reg_req_bus_queue.put(packet)

    def _execute(self):
        """This function executes the functionality of the execute stage of 
        the subcore including reading values from registers, compute results, 
        and pass the instruction with results to the write back stage. 
        """
        while True:
            instr_tuple = yield self.execute_buffer.get() 
            current_pc = instr_tuple[0]
            simt_mask = instr_tuple[1]
            entry_id = instr_tuple[2]
            instr = instr_tuple[3] 
            
            # compose an instance of instruction
            instr_entry = InstrEntry(
                log=self.log,
                config=self.config,
                instr=instr,
                simt_mask=simt_mask,
                pc=current_pc,
                subcore_id=self.subcore_id,
                warp_id=entry_id
            )
            
            # dispatch instruction to operand collector units
            opcode = instr_entry.instr.opcode.split(".")[0]
            if opcode in self.config["alu_instr"]:
                # TODO offload engine should decide
                yield self.opc_fb_alu.instr_entry_queue.put(instr_entry)
            elif opcode in self.config["sfu_instr"]:
                yield self.opc_sfu.instr_entry_queue.put(instr_entry)
            elif opcode in self.config["lsu_instr"]:
                yield self.opc_lsu.instr_entry_queue.put(instr_entry)
            elif opcode in self.config["cfu_instr"]:
                yield self.opc_cfu.instr_entry_queue.put(instr_entry)
            elif opcode in self.config["syncu_instr"]:
                yield self.opc_syncu.instr_entry_queue.put(instr_entry)
            else:
                raise NotImplementedError(
                    "Unsupported opcode: {}".format(opcode)
                )
        return

    def _commit(self):
        """This stage executes the commit stage of the subcore including 
        writing results of destination operands to register file, release 
        the register dependency, release the instruciton stall on the fetch 
        stage, and check whether the current batch of thread blocks finishes 
        the execution. 
        """
        while True:
            instr_entry = yield self.writeback_buffer.get()
            current_pc = instr_entry.pc
            simt_mask = instr_entry.simt_mask
            entry_id = instr_entry.warp_id
            instr = instr_entry.instr

            for i in range(len(instr.dst_operands)):
                dst_op = instr.dst_operands[i]
                reg_addr, reg_size = self.get_subcore_reg_addr(
                    dst_op.reg_prefix, dst_op.reg_index, entry_id
                )

                if simt_mask > 0:
                    # Write results back to register file
                    operand_write_req = OperandWriteReq(
                        base_reg_addr=reg_addr,
                        total_reg_size=reg_size,
                        simt_mask=simt_mask,
                        data=instr_entry.dst_values[i]
                    )
                    self.local_regfile_write_port_id_commit = \
                        (self.local_regfile_write_port_id_commit + 1) \
                        % self.config["num_fb_commit_port"]
                    regfile_write_port_id = \
                        self.base_regfile_write_port_id_commit \
                        + self.local_regfile_write_port_id_commit
                    yield self.rf_io_interface\
                        .write_req_queue[regfile_write_port_id]\
                        .put(operand_write_req)

                    _ = yield self.rf_io_interface.write_resp_queue.get(
                        lambda x: (x.base_reg_addr == reg_addr
                                   and x.total_reg_size == reg_size)
                    )
                
                # Release the dependency in the dependency table
                self.dep_table.entry[entry_id].decrease_write(dst_op.op_str)
                
                # Update register tracking table
                # TODO: support near-bank writeback
                self.reg_track_table.entry[entry_id].write_update(
                    op_str=dst_op.op_str,
                    reg_file_type="far-bank"
                )

            assert instr_entry.processed is True, "Can not pass an " \
                "unprocessed instruction to the writeback stage"
            
            if current_pc == self.warp_pipeline_table.entry[entry_id].pc:
                self.warp_pipeline_table.entry[entry_id].executed = True 

            prog_length = \
                self.warp_info_table.entry[entry_id].prog_length
            if (current_pc + 1) == prog_length:
                self.warp_info_table.entry[entry_id].warp_finished = True
                assert instr.opcode == "ret", "The last instruction is not" \
                    "the return instruction!"

                all_finish = \
                    self.warp_info_table\
                    .check_all_finished(self.num_active_warps)
                if all_finish is True:
                    yield self.finish_exec_resp.put("success") 

        return 
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="simulator.subcore.Subcore" class="name">class <span class="ident">Subcore</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore.Subcore', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore.Subcore" class="source">
    <pre><code>class Subcore:

    def __init__(self, subcore_id, env, config, log, core):
        self.subcore_id = subcore_id 
        self.env = env 
        self.config = config 
        self.log = log
        self.core = core

        self.clock_unit = deepcopy(core.clock_unit) 
        self._loc_str = "Processor ID: {proc_id}, Core ID: {core_id}, " \
            "Subcore ID: {subcore_id}".format(
                proc_id=self.core.processor.proc_id,
                core_id=self.core.core_id,
                subcore_id=self.subcore_id, 
            )

        self.start_exec_cmd = simpy.Store(env, capacity=1)
        self.finish_exec_resp = simpy.Store(env, capacity=1) 

        self.num_active_warps = 0
        self.warp_info_table = WarpInfoTable(config=self.config, log=self.log) 
        self.warp_pipeline_table = \
            WarpPipelineTable(config=self.config, log=self.log)
        self.stack_table = StackTable(config=self.config, log=self.log)
        self.dep_table = DepTable(config=self.config, log=self.log)

        self.reg_file = RegisterFile(
            env=env, 
            log=log, 
            config=self.config,
            clock_unit=self.clock_unit,  
            reg_file_type="far-bank"
        )

        self.reg_track_table = RegTrackTable(
            config=self.config,
            log=self.log,
            reg_file=self.reg_file
        )

        self.rf_io_interface = RegFileOperandIOInterface(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            reg_file=self.reg_file,
            interface_type="far-bank",
        )

        self.reg_move_engine = RegMoveEngine(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            bus_arbiter=self.core.subcore_pg_bus_arbiter,
            engine_type="fb_reg_move"
        )

        self.instr_offload_engine = InstrOffloadEngine(
            env=self.env,
            config=self.config,
            log=self.log,
            reg_move_engine=self.reg_move_engine,
            subcore=self
        )

        # TODO make this port assignment more accurate
        # currently round-robin
        self.local_regfile_write_port_id_commit = 0
        self.base_regfile_write_port_id_commit = \
            self.config["base_regfile_write_port_id_fb_commit"]

        self.decode_buffer = []
        self.num_free_decode_buffer_slots = []
        for i in range(self.config["max_num_warp_per_subcore"]):
            self.decode_buffer.append(simpy.Store(env))
            self.num_free_decode_buffer_slots.append(
                self.config["decode_buffer_size"])

        self.execute_buffer = simpy.Store(
            env, capacity=(self.config["subcore_execute_buffer_size"])
        )

        self.writeback_buffer = simpy.Store(
            env, capacity=self.config["subcore_writeback_buffer_size"]
        )

        self.sync_buffer = simpy.Store(
            env, capacity=self.config["max_num_warp_per_subcore"]
        )

        self.bus_receive_buffer = simpy.Store(
            env, capacity=self.config["subcore_bus_receive_buffer_size"]
        )

        self.reg_base_ptr = 0

        # Execution Stage
        # arithemtic logic unit
        self.fb_alu = ArithmeticLogicUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            alu_type="far-bank"
        )
        self.opc_fb_alu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.fb_alu,
            opc_type="fb_alu"
        )
        
        # special function unit
        self.sfu = SpecialFunctionUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            subcore=self
        )
        self.opc_sfu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.sfu,
            opc_type="sfu"
        )

        # load-store unit
        self.lsu = LoadStoreUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            subcore=self
        )
        self.opc_lsu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.lsu,
            opc_type="lsu"
        )

        # control-flow unit
        self.cfu = ControlFlowUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            subcore=self
        )
        self.opc_cfu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.cfu,
            opc_type="cfu"
        )

        # synchronization unit
        self.syncu = SynchronizationUnit(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            subcore=self
        )
        self.opc_syncu = OperandCollector(
            env=self.env,
            log=self.log,
            config=self.config,
            clock_unit=self.clock_unit,
            backend=self,
            regfile_io_interface=self.rf_io_interface,
            execution_unit=self.syncu,
            opc_type="syncu"
        )

        # Spawn a process for the fetch and decode subcore stages
        self.env.process(self._fetch_and_decode())

        # Spawn processes for the issue subcore stage
        for i in range(self.config["max_num_warp_per_subcore"]):
            self.env.process(self._issue(entry_id=i))

        # Spawn a process for the execute subcore stage 
        self.env.process(self._execute())

        # Spawn a process for the commit subcore stage 
        self.env.process(self._commit())

        # Spawn a process to receive data from the bus
        self.env.process(self._receive_bus_data())
        return 

    def reset_status(self):
        """Reset hardware status of subcores.This function is usually used 
        to reset subcore status between different calls of executing thread 
        blocks. 
        """
        self.num_active_warps = 0
        self.reg_base_ptr = 0

        # Reset the tables in the subcore  
        self.warp_info_table.reset()
        self.warp_pipeline_table.reset() 
        self.stack_table.reset() 
        self.dep_table.reset()
        self.reg_track_table.reset()

        return 

    def check_warp_usage(self, warp_usage):
        """Return whether the available slots in the warp table is sufficient 
        to accomodate a new thread block 
        """
        new_active_warps = self.num_active_warps + warp_usage 
        if new_active_warps > self.config["max_num_warp_per_subcore"]:
            return False 
        return True 

    def check_reg_usage(self, reg_usage_in_bytes):
        """Returen whether the available amount of register file is sufficient
        to accomodate a new thread block 
        """
        new_base_ptr = self.reg_base_ptr + reg_usage_in_bytes 
        if new_base_ptr > self.config["subcore_reg_file_size"]:
            return False 
        return True 

    def _load_from_icache(self, entry_id, pc):
        """This function loads the instruction from the instruction cache and 
        fill in the corresponding entry of the fetch table. 

        Args:
            entry_id: the position of the entry in the fetch table
            pc: the program counter of the instruction 
        """
        req = InstrLoadReq(
            subcore_id=self.subcore_id, entry_id=entry_id, pc=pc
        )
        yield self.core.icache.load_req_queque.put(req)
        self.log.debug(
            "{loc} at {time_stamp} cycle: Issue load for the "
            "instr with PC={pc} from the entry {entry_id}".format(
                loc=self._loc_str, time_stamp=self.env.now, pc=pc, 
                entry_id=entry_id
            )
        )

        resp = yield self.core.icache.load_resp_queue.get(
            lambda x: ((x.subcore_id == self.subcore_id) 
                       and (x.entry_id == entry_id) and (x.pc == pc)) 
        )
        self.log.debug(
            "{loc} at {time_stamp} cycle: Get the instruction "
            "with PC={pc} for the entry {entry_id}".format(
                loc=self._loc_str, time_stamp=self.env.now,
                pc=pc, entry_id=entry_id,
            )
        )

        self.warp_pipeline_table.entry[entry_id].instr = resp.instr 
        self.warp_pipeline_table.entry[entry_id].valid = True 

        return 

    def _need_fetch_stall(self, instr):
        """Check the fetch stage needs to be stalled waiting for the execution
        of the current instruction. We will stall the fetch stage on any 
        control flow instructions or synchronization instructions. 

        Args:
            instr: the instruction passed to be checked. 

        Returns:
            A boolean value, True or False, to indicate whether the fetch stage
                needs to be stalled. 
        """
        # Check whether it is a control flow instruction 
        if "dst_pc" in instr.metadata:
            return True 
        
        # Check whether it is a barrier instruction 
        if "bar_id" in instr.metadata: 
            return True 

        return False 

    def _fetch_and_decode(self):
        """This function executes the fetch and decode stages of the subcore 
        """
        while True:
            start_exec = yield self.start_exec_cmd.get() 
            assert start_exec == "start", "Unrecognized " \
                "commands: {}".format(start_exec) 

            curr_ptr = 0
            while True:
                # Step 1: check the exit condition
                all_finish = self.warp_pipeline_table\
                    .check_all_finished(self.num_active_warps)
                if all_finish is True:
                    break 

                curr_entry = deepcopy(self.warp_pipeline_table.entry[curr_ptr])

                # Step 2: skip the current warp if it is finished 
                if curr_entry.warp_finished:
                    curr_ptr = (curr_ptr + 1) % self.num_active_warps 
                    yield self.env.timeout(1 * self.clock_unit)
                    continue 

                # Step 3: check whether the current instruction is valid
                if not curr_entry.valid: 
                    if not curr_entry.issued_to_icache: 
                        self.warp_pipeline_table.entry[curr_ptr]\
                            .issued_to_icache = True
                        self.env.process(
                            self._load_from_icache(curr_ptr, curr_entry.pc)
                        )
                        curr_ptr = (curr_ptr + 1) % self.num_active_warps 

                    yield self.env.timeout(1 * self.clock_unit)
                    continue 

                # self.log.debug("{loc}: Entry {entry_id} got a valid " \
                #        "instruction with pc={pc}".format(
                #            loc=self._loc_str, 
                #            entry_id=curr_ptr, 
                #            pc=curr_entry.pc
                #        )
                #    )

                # Step 4: push into the next stage if resources are available 
                if not curr_entry.issued_to_decode:
                    if self.num_free_decode_buffer_slots[curr_ptr] > 0:
                        self.num_free_decode_buffer_slots[curr_ptr] = (
                            self.num_free_decode_buffer_slots[curr_ptr] - 1
                        )
                        pc = deepcopy(curr_entry.pc)
                        simt_mask = deepcopy(
                            self.stack_table.entry[curr_ptr].get_simt_mask() 
                        )
                        yield self.decode_buffer[curr_ptr].put(
                            (pc, simt_mask, curr_entry.instr)
                        ) 
                        self.warp_pipeline_table.entry[
                            curr_ptr].issued_to_decode = True 
                    else:
                        if curr_entry.skip_resource_contention: 
                            self.warp_pipeline_table.entry[
                                curr_ptr].skip_resource_contention = False 
                            curr_ptr = (curr_ptr + 1) % self.num_active_warps 
                        yield self.env.timeout(1 * self.clock_unit) 

                    continue 

                # Step 5: stall the fetch stage if needed 
                if self._need_fetch_stall(curr_entry.instr):
                    if not curr_entry.executed:
                        curr_ptr = (curr_ptr + 1) % self.num_active_warps 

                        yield self.env.timeout(1 * self.clock_unit) 
                        continue 

                # Step 6: check the SIMT stack to get the correct next PC
                next_pc = curr_entry.next_pc 
                while self.stack_table.entry[curr_ptr].check_converge(next_pc):
                    self.stack_table.entry[curr_ptr].pop() 
                    top_entry = self.stack_table.entry[curr_ptr].top()
                    next_pc = top_entry[1] 
                    yield self.env.timeout(1 * self.clock_unit)

                if next_pc >= self.warp_info_table.entry[curr_ptr].prog_length:
                    self.warp_pipeline_table\
                        .entry[curr_ptr].warp_finished = True 

                    yield self.env.timeout(1 * self.clock_unit)
                    continue 

                # Step 7: generate a new entry for the next PC
                new_warp_pipeline_table_entry = \
                    WarpPipelineTableEntry(pc=next_pc)
                self.warp_pipeline_table.entry[curr_ptr] = \
                    deepcopy(new_warp_pipeline_table_entry) 

                yield self.env.timeout(1 * self.clock_unit) 

        return

    def _issue(self, entry_id):
        """This function executes the issue stage of subcore including 
        checking operand dependencies and send instructions to the next 
        stage 
        """
        while True:
            instr_tuple = yield self.decode_buffer[entry_id].get()
            self.num_free_decode_buffer_slots[entry_id] += 1
            current_pc = instr_tuple[0]
            simt_mask = instr_tuple[1]
            instr = instr_tuple[2]

            self.log.debug(
                "{loc} Entry {entry_id} start checking the "
                "dependency of {instr} at {time_stamp} cycle".format(
                    loc=self._loc_str, entry_id=entry_id,
                    instr=instr.instr_str, time_stamp=self.env.now
                )
            )

            src_ops = []
            dst_ops = []

            if "pred_reg" in instr.metadata:
                src_ops.append(instr.metadata["pred_reg"].op_str)

            for each_op in instr.src_operands:
                if each_op.isreg():
                    src_ops.append(each_op.op_str)
            # self.log.debug("source operands: {}".format(src_ops))

            for each_op in instr.dst_operands:
                if each_op.isreg():
                    dst_ops.append(each_op.op_str) 
            # self.log.debug("destination operands: {}".format(dst_ops))

            # Check the dependency table until all dependencies are cleared 
            while True:
                yield self.env.timeout(1 * self.clock_unit)

                break_cond = True 
                
                for each_op in src_ops:
                    if not self.dep_table.entry[entry_id].check_read(each_op):
                        break_cond = False 
                        break 

                for each_op in dst_ops:
                    if not self.dep_table.entry[entry_id].check_write(each_op):
                        break_cond = False 
                        break 

                if break_cond:
                    break 

            self.log.debug(
                "{loc} Entry {entry_id} finished checking the "
                "dependency of {instr} at {time_stamp} cycle".format(
                    loc=self._loc_str, entry_id=entry_id,
                    instr=instr.instr_str, time_stamp=self.env.now
                )
            )

            # Update the dependency table to pend other instructions 
            for each_op in src_ops:
                self.dep_table.entry[entry_id].increase_read(each_op) 

            for each_op in dst_ops:
                self.dep_table.entry[entry_id].increase_write(each_op)

            # (TODO) model a more accurate timing here for recording register 
            # dependencies
            yield self.env.timeout(1 * self.clock_unit) 

            yield self.execute_buffer.put(
                (current_pc, simt_mask, entry_id, instr)
            )
        return 

    def get_subcore_reg_addr(self, reg_prefix, reg_index, entry_id):
        """This function calculates the absolute addrss of a register in the 
        register file of subcore. It also returns the size of registers with 
        the same name across threads in the whole warp.  
        
        Args:
            reg_prefix: the prefix of register name 
            reg_index: the index of the register 
            entry_id: the warp ID of this register 

        Returns:
            (reg_addr, reg_size): the stating address of this register in the 
                register file and the size of the whole register 
        """
        reg_base_addr = self.warp_info_table\
            .entry[entry_id].subcore_reg_base_addr 
        prefix_reg_base_addr = (
            reg_base_addr 
            + self.warp_info_table.entry[entry_id].prog_reg_offset[reg_prefix]
        )
        reg_size = self.warp_info_table\
            .entry[entry_id].prog_reg_size[reg_prefix]
        reg_addr = prefix_reg_base_addr + reg_index * reg_size

        self.log.debug(
            "{loc} Entry {entry_id} {reg_prefix}{reg_index} " 
            "starting from {reg_addr} with size {reg_size}".format(
                loc=self._loc_str, entry_id=entry_id, 
                reg_prefix=reg_prefix, reg_index=reg_index,
                reg_addr=reg_addr, reg_size=reg_size 
            )
        )
        return (reg_addr, reg_size)

    def get_param_value(self, param_name, entry_id):
        """This function gets the value of parameters including kernel function
        arguments and shared memory parameter. 

        Args:
            param_name: the parameter name
            entry_id: the entry ID the current warp. This ID is used to locate 
                shared memory base address and offset for the dynamically 
                allocated shared memory space 

        Returns:
            param_value: the value of parameter in its corresponding type 
        """
        prog_smem_offset = \
            self.warp_info_table.entry[entry_id].prog_smem_offset
        if param_name in self.core.param_dict:
            return self.core.param_dict[param_name]
        elif param_name in prog_smem_offset:
            base_addr = self.warp_info_table.entry[entry_id].smem_base_addr
            offset = (
                self.warp_info_table
                .entry[entry_id].prog_smem_offset[param_name]
            ) 
            return base_addr + offset 
        else: 
            raise NotImplementedError(
                "Unknown parameter:{}".format(param_name)
            )
        return 

    def get_special_reg_value(self, reg_name, entry_id):
        """This function is used to get the value of special registers storing 
        SIMT thread information, such as block ID and thread ID. 

        Args:
            reg_name: the name of special register 
            entry_id: the entry ID of the current warp so that block ID and 
                thread ID can be accurately located. 

        Returns:
            reg_value: an integer if the requested registr has the same value 
                for all threads in the same warp, or a list of values for 
                different values of threads in the same warp. 
        """
        index_mapper = {"z": 0, "y": 1, "x": 2}
        reg_prefix = reg_name.split(".")[0]
        reg_index = index_mapper[reg_name.split(".")[1]]

        if reg_prefix == "%ntid":
            return self.core.block_dim[reg_index]
        elif reg_prefix == "%ctaid":
            return self.warp_info_table.entry[entry_id].block_id[reg_index] 
        elif reg_prefix == "%tid":
            start_id = self.warp_info_table.entry[entry_id].thread_id[reg_index]
            if reg_index != 2:
                return start_id 
            else: 
                value_list = list(range(
                    start_id, start_id + self.config["num_threads_per_warp"]))
                return value_list 
        elif reg_prefix == "%nctaid":
            return self.core.grid_dim[reg_index] 
        else:
            raise NotImplementedError(
                "Unknown special register: {}".format(reg_name)
            )
        return 

    def _receive_bus_data(self):
        """This function receives data from subcore-pg buses
        """
        while True:
            packet = yield self.bus_receive_buffer.get()
            if isinstance(packet, RegMoveReq):
                self.reg_move_engine\
                    .reg_req_bus_queue.put(packet)

    def _execute(self):
        """This function executes the functionality of the execute stage of 
        the subcore including reading values from registers, compute results, 
        and pass the instruction with results to the write back stage. 
        """
        while True:
            instr_tuple = yield self.execute_buffer.get() 
            current_pc = instr_tuple[0]
            simt_mask = instr_tuple[1]
            entry_id = instr_tuple[2]
            instr = instr_tuple[3] 
            
            # compose an instance of instruction
            instr_entry = InstrEntry(
                log=self.log,
                config=self.config,
                instr=instr,
                simt_mask=simt_mask,
                pc=current_pc,
                subcore_id=self.subcore_id,
                warp_id=entry_id
            )
            
            # dispatch instruction to operand collector units
            opcode = instr_entry.instr.opcode.split(".")[0]
            if opcode in self.config["alu_instr"]:
                # TODO offload engine should decide
                yield self.opc_fb_alu.instr_entry_queue.put(instr_entry)
            elif opcode in self.config["sfu_instr"]:
                yield self.opc_sfu.instr_entry_queue.put(instr_entry)
            elif opcode in self.config["lsu_instr"]:
                yield self.opc_lsu.instr_entry_queue.put(instr_entry)
            elif opcode in self.config["cfu_instr"]:
                yield self.opc_cfu.instr_entry_queue.put(instr_entry)
            elif opcode in self.config["syncu_instr"]:
                yield self.opc_syncu.instr_entry_queue.put(instr_entry)
            else:
                raise NotImplementedError(
                    "Unsupported opcode: {}".format(opcode)
                )
        return

    def _commit(self):
        """This stage executes the commit stage of the subcore including 
        writing results of destination operands to register file, release 
        the register dependency, release the instruciton stall on the fetch 
        stage, and check whether the current batch of thread blocks finishes 
        the execution. 
        """
        while True:
            instr_entry = yield self.writeback_buffer.get()
            current_pc = instr_entry.pc
            simt_mask = instr_entry.simt_mask
            entry_id = instr_entry.warp_id
            instr = instr_entry.instr

            for i in range(len(instr.dst_operands)):
                dst_op = instr.dst_operands[i]
                reg_addr, reg_size = self.get_subcore_reg_addr(
                    dst_op.reg_prefix, dst_op.reg_index, entry_id
                )

                if simt_mask > 0:
                    # Write results back to register file
                    operand_write_req = OperandWriteReq(
                        base_reg_addr=reg_addr,
                        total_reg_size=reg_size,
                        simt_mask=simt_mask,
                        data=instr_entry.dst_values[i]
                    )
                    self.local_regfile_write_port_id_commit = \
                        (self.local_regfile_write_port_id_commit + 1) \
                        % self.config["num_fb_commit_port"]
                    regfile_write_port_id = \
                        self.base_regfile_write_port_id_commit \
                        + self.local_regfile_write_port_id_commit
                    yield self.rf_io_interface\
                        .write_req_queue[regfile_write_port_id]\
                        .put(operand_write_req)

                    _ = yield self.rf_io_interface.write_resp_queue.get(
                        lambda x: (x.base_reg_addr == reg_addr
                                   and x.total_reg_size == reg_size)
                    )
                
                # Release the dependency in the dependency table
                self.dep_table.entry[entry_id].decrease_write(dst_op.op_str)
                
                # Update register tracking table
                # TODO: support near-bank writeback
                self.reg_track_table.entry[entry_id].write_update(
                    op_str=dst_op.op_str,
                    reg_file_type="far-bank"
                )

            assert instr_entry.processed is True, "Can not pass an " \
                "unprocessed instruction to the writeback stage"
            
            if current_pc == self.warp_pipeline_table.entry[entry_id].pc:
                self.warp_pipeline_table.entry[entry_id].executed = True 

            prog_length = \
                self.warp_info_table.entry[entry_id].prog_length
            if (current_pc + 1) == prog_length:
                self.warp_info_table.entry[entry_id].warp_finished = True
                assert instr.opcode == "ret", "The last instruction is not" \
                    "the return instruction!"

                all_finish = \
                    self.warp_info_table\
                    .check_all_finished(self.num_active_warps)
                if all_finish is True:
                    yield self.finish_exec_resp.put("success") 

        return 
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#simulator.subcore.Subcore">Subcore</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="simulator.subcore.Subcore.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, subcore_id, env, config, log, core)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore.Subcore.__init__', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore.Subcore.__init__" class="source">
    <pre><code>def __init__(self, subcore_id, env, config, log, core):
    self.subcore_id = subcore_id 
    self.env = env 
    self.config = config 
    self.log = log
    self.core = core
    self.clock_unit = deepcopy(core.clock_unit) 
    self._loc_str = "Processor ID: {proc_id}, Core ID: {core_id}, " \
        "Subcore ID: {subcore_id}".format(
            proc_id=self.core.processor.proc_id,
            core_id=self.core.core_id,
            subcore_id=self.subcore_id, 
        )
    self.start_exec_cmd = simpy.Store(env, capacity=1)
    self.finish_exec_resp = simpy.Store(env, capacity=1) 
    self.num_active_warps = 0
    self.warp_info_table = WarpInfoTable(config=self.config, log=self.log) 
    self.warp_pipeline_table = \
        WarpPipelineTable(config=self.config, log=self.log)
    self.stack_table = StackTable(config=self.config, log=self.log)
    self.dep_table = DepTable(config=self.config, log=self.log)
    self.reg_file = RegisterFile(
        env=env, 
        log=log, 
        config=self.config,
        clock_unit=self.clock_unit,  
        reg_file_type="far-bank"
    )
    self.reg_track_table = RegTrackTable(
        config=self.config,
        log=self.log,
        reg_file=self.reg_file
    )
    self.rf_io_interface = RegFileOperandIOInterface(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        reg_file=self.reg_file,
        interface_type="far-bank",
    )
    self.reg_move_engine = RegMoveEngine(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        backend=self,
        regfile_io_interface=self.rf_io_interface,
        bus_arbiter=self.core.subcore_pg_bus_arbiter,
        engine_type="fb_reg_move"
    )
    self.instr_offload_engine = InstrOffloadEngine(
        env=self.env,
        config=self.config,
        log=self.log,
        reg_move_engine=self.reg_move_engine,
        subcore=self
    )
    # TODO make this port assignment more accurate
    # currently round-robin
    self.local_regfile_write_port_id_commit = 0
    self.base_regfile_write_port_id_commit = \
        self.config["base_regfile_write_port_id_fb_commit"]
    self.decode_buffer = []
    self.num_free_decode_buffer_slots = []
    for i in range(self.config["max_num_warp_per_subcore"]):
        self.decode_buffer.append(simpy.Store(env))
        self.num_free_decode_buffer_slots.append(
            self.config["decode_buffer_size"])
    self.execute_buffer = simpy.Store(
        env, capacity=(self.config["subcore_execute_buffer_size"])
    )
    self.writeback_buffer = simpy.Store(
        env, capacity=self.config["subcore_writeback_buffer_size"]
    )
    self.sync_buffer = simpy.Store(
        env, capacity=self.config["max_num_warp_per_subcore"]
    )
    self.bus_receive_buffer = simpy.Store(
        env, capacity=self.config["subcore_bus_receive_buffer_size"]
    )
    self.reg_base_ptr = 0
    # Execution Stage
    # arithemtic logic unit
    self.fb_alu = ArithmeticLogicUnit(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        backend=self,
        alu_type="far-bank"
    )
    self.opc_fb_alu = OperandCollector(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        backend=self,
        regfile_io_interface=self.rf_io_interface,
        execution_unit=self.fb_alu,
        opc_type="fb_alu"
    )
    
    # special function unit
    self.sfu = SpecialFunctionUnit(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        subcore=self
    )
    self.opc_sfu = OperandCollector(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        backend=self,
        regfile_io_interface=self.rf_io_interface,
        execution_unit=self.sfu,
        opc_type="sfu"
    )
    # load-store unit
    self.lsu = LoadStoreUnit(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        subcore=self
    )
    self.opc_lsu = OperandCollector(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        backend=self,
        regfile_io_interface=self.rf_io_interface,
        execution_unit=self.lsu,
        opc_type="lsu"
    )
    # control-flow unit
    self.cfu = ControlFlowUnit(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        subcore=self
    )
    self.opc_cfu = OperandCollector(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        backend=self,
        regfile_io_interface=self.rf_io_interface,
        execution_unit=self.cfu,
        opc_type="cfu"
    )
    # synchronization unit
    self.syncu = SynchronizationUnit(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        subcore=self
    )
    self.opc_syncu = OperandCollector(
        env=self.env,
        log=self.log,
        config=self.config,
        clock_unit=self.clock_unit,
        backend=self,
        regfile_io_interface=self.rf_io_interface,
        execution_unit=self.syncu,
        opc_type="syncu"
    )
    # Spawn a process for the fetch and decode subcore stages
    self.env.process(self._fetch_and_decode())
    # Spawn processes for the issue subcore stage
    for i in range(self.config["max_num_warp_per_subcore"]):
        self.env.process(self._issue(entry_id=i))
    # Spawn a process for the execute subcore stage 
    self.env.process(self._execute())
    # Spawn a process for the commit subcore stage 
    self.env.process(self._commit())
    # Spawn a process to receive data from the bus
    self.env.process(self._receive_bus_data())
    return 
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="simulator.subcore.Subcore.check_reg_usage">
    <p>def <span class="ident">check_reg_usage</span>(</p><p>self, reg_usage_in_bytes)</p>
    </div>
    

    
  
    <div class="desc"><p>Returen whether the available amount of register file is sufficient
to accomodate a new thread block</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore.Subcore.check_reg_usage', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore.Subcore.check_reg_usage" class="source">
    <pre><code>def check_reg_usage(self, reg_usage_in_bytes):
    """Returen whether the available amount of register file is sufficient
    to accomodate a new thread block 
    """
    new_base_ptr = self.reg_base_ptr + reg_usage_in_bytes 
    if new_base_ptr > self.config["subcore_reg_file_size"]:
        return False 
    return True 
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="simulator.subcore.Subcore.check_warp_usage">
    <p>def <span class="ident">check_warp_usage</span>(</p><p>self, warp_usage)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether the available slots in the warp table is sufficient 
to accomodate a new thread block</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore.Subcore.check_warp_usage', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore.Subcore.check_warp_usage" class="source">
    <pre><code>def check_warp_usage(self, warp_usage):
    """Return whether the available slots in the warp table is sufficient 
    to accomodate a new thread block 
    """
    new_active_warps = self.num_active_warps + warp_usage 
    if new_active_warps > self.config["max_num_warp_per_subcore"]:
        return False 
    return True 
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="simulator.subcore.Subcore.get_param_value">
    <p>def <span class="ident">get_param_value</span>(</p><p>self, param_name, entry_id)</p>
    </div>
    

    
  
    <div class="desc"><p>This function gets the value of parameters including kernel function
arguments and shared memory parameter. </p>
<p>Args:
    param_name: the parameter name
    entry_id: the entry ID the current warp. This ID is used to locate 
        shared memory base address and offset for the dynamically 
        allocated shared memory space </p>
<p>Returns:
    param_value: the value of parameter in its corresponding type</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore.Subcore.get_param_value', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore.Subcore.get_param_value" class="source">
    <pre><code>def get_param_value(self, param_name, entry_id):
    """This function gets the value of parameters including kernel function
    arguments and shared memory parameter. 
    Args:
        param_name: the parameter name
        entry_id: the entry ID the current warp. This ID is used to locate 
            shared memory base address and offset for the dynamically 
            allocated shared memory space 
    Returns:
        param_value: the value of parameter in its corresponding type 
    """
    prog_smem_offset = \
        self.warp_info_table.entry[entry_id].prog_smem_offset
    if param_name in self.core.param_dict:
        return self.core.param_dict[param_name]
    elif param_name in prog_smem_offset:
        base_addr = self.warp_info_table.entry[entry_id].smem_base_addr
        offset = (
            self.warp_info_table
            .entry[entry_id].prog_smem_offset[param_name]
        ) 
        return base_addr + offset 
    else: 
        raise NotImplementedError(
            "Unknown parameter:{}".format(param_name)
        )
    return 
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="simulator.subcore.Subcore.get_special_reg_value">
    <p>def <span class="ident">get_special_reg_value</span>(</p><p>self, reg_name, entry_id)</p>
    </div>
    

    
  
    <div class="desc"><p>This function is used to get the value of special registers storing 
SIMT thread information, such as block ID and thread ID. </p>
<p>Args:
    reg_name: the name of special register 
    entry_id: the entry ID of the current warp so that block ID and 
        thread ID can be accurately located. </p>
<p>Returns:
    reg_value: an integer if the requested registr has the same value 
        for all threads in the same warp, or a list of values for 
        different values of threads in the same warp.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore.Subcore.get_special_reg_value', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore.Subcore.get_special_reg_value" class="source">
    <pre><code>def get_special_reg_value(self, reg_name, entry_id):
    """This function is used to get the value of special registers storing 
    SIMT thread information, such as block ID and thread ID. 
    Args:
        reg_name: the name of special register 
        entry_id: the entry ID of the current warp so that block ID and 
            thread ID can be accurately located. 
    Returns:
        reg_value: an integer if the requested registr has the same value 
            for all threads in the same warp, or a list of values for 
            different values of threads in the same warp. 
    """
    index_mapper = {"z": 0, "y": 1, "x": 2}
    reg_prefix = reg_name.split(".")[0]
    reg_index = index_mapper[reg_name.split(".")[1]]
    if reg_prefix == "%ntid":
        return self.core.block_dim[reg_index]
    elif reg_prefix == "%ctaid":
        return self.warp_info_table.entry[entry_id].block_id[reg_index] 
    elif reg_prefix == "%tid":
        start_id = self.warp_info_table.entry[entry_id].thread_id[reg_index]
        if reg_index != 2:
            return start_id 
        else: 
            value_list = list(range(
                start_id, start_id + self.config["num_threads_per_warp"]))
            return value_list 
    elif reg_prefix == "%nctaid":
        return self.core.grid_dim[reg_index] 
    else:
        raise NotImplementedError(
            "Unknown special register: {}".format(reg_name)
        )
    return 
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="simulator.subcore.Subcore.get_subcore_reg_addr">
    <p>def <span class="ident">get_subcore_reg_addr</span>(</p><p>self, reg_prefix, reg_index, entry_id)</p>
    </div>
    

    
  
    <div class="desc"><p>This function calculates the absolute addrss of a register in the 
register file of subcore. It also returns the size of registers with 
the same name across threads in the whole warp.  </p>
<p>Args:
    reg_prefix: the prefix of register name 
    reg_index: the index of the register 
    entry_id: the warp ID of this register </p>
<p>Returns:
    (reg_addr, reg_size): the stating address of this register in the 
        register file and the size of the whole register</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore.Subcore.get_subcore_reg_addr', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore.Subcore.get_subcore_reg_addr" class="source">
    <pre><code>def get_subcore_reg_addr(self, reg_prefix, reg_index, entry_id):
    """This function calculates the absolute addrss of a register in the 
    register file of subcore. It also returns the size of registers with 
    the same name across threads in the whole warp.  
    
    Args:
        reg_prefix: the prefix of register name 
        reg_index: the index of the register 
        entry_id: the warp ID of this register 
    Returns:
        (reg_addr, reg_size): the stating address of this register in the 
            register file and the size of the whole register 
    """
    reg_base_addr = self.warp_info_table\
        .entry[entry_id].subcore_reg_base_addr 
    prefix_reg_base_addr = (
        reg_base_addr 
        + self.warp_info_table.entry[entry_id].prog_reg_offset[reg_prefix]
    )
    reg_size = self.warp_info_table\
        .entry[entry_id].prog_reg_size[reg_prefix]
    reg_addr = prefix_reg_base_addr + reg_index * reg_size
    self.log.debug(
        "{loc} Entry {entry_id} {reg_prefix}{reg_index} " 
        "starting from {reg_addr} with size {reg_size}".format(
            loc=self._loc_str, entry_id=entry_id, 
            reg_prefix=reg_prefix, reg_index=reg_index,
            reg_addr=reg_addr, reg_size=reg_size 
        )
    )
    return (reg_addr, reg_size)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="simulator.subcore.Subcore.reset_status">
    <p>def <span class="ident">reset_status</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Reset hardware status of subcores.This function is usually used 
to reset subcore status between different calls of executing thread 
blocks.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-simulator.subcore.Subcore.reset_status', this);">Show source &equiv;</a></p>
  <div id="source-simulator.subcore.Subcore.reset_status" class="source">
    <pre><code>def reset_status(self):
    """Reset hardware status of subcores.This function is usually used 
    to reset subcore status between different calls of executing thread 
    blocks. 
    """
    self.num_active_warps = 0
    self.reg_base_ptr = 0
    # Reset the tables in the subcore  
    self.warp_info_table.reset()
    self.warp_pipeline_table.reset() 
    self.stack_table.reset() 
    self.dep_table.reset()
    self.reg_track_table.reset()
    return 
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="simulator.subcore.Subcore.base_regfile_write_port_id_commit" class="name">var <span class="ident">base_regfile_write_port_id_commit</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.bus_receive_buffer" class="name">var <span class="ident">bus_receive_buffer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.cfu" class="name">var <span class="ident">cfu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.clock_unit" class="name">var <span class="ident">clock_unit</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.config" class="name">var <span class="ident">config</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.core" class="name">var <span class="ident">core</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.decode_buffer" class="name">var <span class="ident">decode_buffer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.dep_table" class="name">var <span class="ident">dep_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.env" class="name">var <span class="ident">env</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.execute_buffer" class="name">var <span class="ident">execute_buffer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.fb_alu" class="name">var <span class="ident">fb_alu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.finish_exec_resp" class="name">var <span class="ident">finish_exec_resp</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.instr_offload_engine" class="name">var <span class="ident">instr_offload_engine</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.local_regfile_write_port_id_commit" class="name">var <span class="ident">local_regfile_write_port_id_commit</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.lsu" class="name">var <span class="ident">lsu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.num_active_warps" class="name">var <span class="ident">num_active_warps</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.num_free_decode_buffer_slots" class="name">var <span class="ident">num_free_decode_buffer_slots</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.opc_cfu" class="name">var <span class="ident">opc_cfu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.opc_fb_alu" class="name">var <span class="ident">opc_fb_alu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.opc_lsu" class="name">var <span class="ident">opc_lsu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.opc_sfu" class="name">var <span class="ident">opc_sfu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.opc_syncu" class="name">var <span class="ident">opc_syncu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.reg_base_ptr" class="name">var <span class="ident">reg_base_ptr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.reg_file" class="name">var <span class="ident">reg_file</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.reg_move_engine" class="name">var <span class="ident">reg_move_engine</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.reg_track_table" class="name">var <span class="ident">reg_track_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.rf_io_interface" class="name">var <span class="ident">rf_io_interface</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.sfu" class="name">var <span class="ident">sfu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.stack_table" class="name">var <span class="ident">stack_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.start_exec_cmd" class="name">var <span class="ident">start_exec_cmd</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.subcore_id" class="name">var <span class="ident">subcore_id</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.sync_buffer" class="name">var <span class="ident">sync_buffer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.syncu" class="name">var <span class="ident">syncu</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.warp_info_table" class="name">var <span class="ident">warp_info_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.warp_pipeline_table" class="name">var <span class="ident">warp_pipeline_table</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="simulator.subcore.Subcore.writeback_buffer" class="name">var <span class="ident">writeback_buffer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
